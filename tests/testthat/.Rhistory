expect_equal(extractMIDAS(dumb_midas), dumb_midas)
expect_error(extractMIDAS(dumb_midas[,-1]), "'ID:type' is missing")
expect_error(extractMIDAS(dumb_midas[,c(-2, -3)]), "'TR' field is missing")
expect_error(extractMIDAS(dumb_midas[,c(-5, -6)]), "'DV' field is missing")
})
dumb_activity = c("N1", "N2")
test_that("extractBasalActivity works with a vector", {
expect_equal(extractBasalActivity(dumb_activity), dumb_activity)
})
test_that("extractBasalActivity works with a filename", {
expect_equal(extractBasalActivity("dumb_basal.dat"), dumb_activity)
})
test_that("extractBasalActivity works with empty string", {
expect_equal(extractBasalActivity(""), c(""))
})
test_that("extractBasalActivity raise an error for non existing files", {
suppressWarnings(expect_error(extractBasalActivity("does_not_exist"), "cannot open the connection"))
})
context("Model creation with R objects")
dumb_midas[,1] = c("c", "t", "t", "t", "t")
dumb_midas[,c(2,3)] = cbind(c(0,1,1,0,0), c(0,0,1,0,1)) # Perturbations
dumb_midas[,c(5,6)] = cbind(c(1, 2, 1.5, 1, 0.5), c(1, 4, 2, 1, 0.5))
no_control_midas = dumb_midas[-1,]
no_perturbations_midas = dumb_midas[,c(-2, -3)]
dumb_variation = dumb_midas
dumb_variation[,c(5,6)] = 0.1
test_that("createModel works with R objects", {
expect_silent( suppressMessages(createModel(dumb_structure, dumb_activity, dumb_midas, dumb_variation, inits=10)) ) # With error model
})
test_that("createModel works without error model", {
expect_silent( suppressMessages(createModel(dumb_structure, dumb_activity, dumb_midas, inits=10)) )
})
# Create a model for later use
dumb_model = suppressMessages(createModel(dumb_structure, dumb_activity, dumb_midas, dumb_variation, inits=10))
test_that("createModelSet works with R objects", {
expect_silent( suppressMessages(createModelSet(dumb_structure, dumb_activity, list(m1=dumb_midas, m2=dumb_midas), list(m1=dumb_variation, m2=dumb_variation), model_name=c("m1", "m2"), inits=10)) )
})
context("Model core data extraction")
test_that("extractModelCore works as expected", {
expect_silent(suppressMessages(extractModelCore(dumb_structure, dumb_activity, dumb_midas)))
})
test_that("extractModelCore error when perturbations are missing", {
expect_error(suppressMessages(extractModelCore(dumb_structure, dumb_activity, no_perturbations_midas)))
})
context("Limit cases for createModel")
test_that("Limit cases number of initialisations behave as expected", {
expect_error(suppressMessages(createModel(dumb_structure, dumb_activity, dumb_midas, inits=0)), "Number of initialisations") # No initialisation
#expect_silent(suppressMessages(createModel(dumb_structure, dumb_activity, dumb_midas, inits=1))) # Only one initialisation
})
test_that("Missing argument raise an error", {
expect_error(suppressMessages(createModel(dumb_activity, dumb_midas, inits=10)))
})
test_that("Misplaced arguments raise an error", {
expect_error(suppressMessages(createModel(dumb_activity, dumb_structure, dumb_midas, inits=10)))
})
test_that("createModel raises an error when arguments are misordered", {
expect_warning( createModel(dumb_structure, dumb_midas, dumb_variation, inits=10), "No basal names")
})
test_that("createModel raises an error when controls are missing", {
expect_error(createModel(dumb_structure, dumb_activity, no_control_midas, inits=10), "Control experiments are required")
})
test_that("createModel raises an error when perturbations informations are missing", {
expect_error(createModel(dumb_structure, dumb_activity, no_perturbations_midas, inits=10))
})
test_that("createModel with remove readouts (and limit case one readout)", {
expect_silent(suppressMessages(createModel(dumb_structure, dumb_activity, dumb_midas, unused_readouts=c("N3"), inits=10)))
})
dumb_structure
dumb_activity
model_structure=dumb_structure
basal_activity = dumb_activity
data_filename = dumb_midas
var_filename=""
dont_perturb=c()
dont_read=("N3")
MIN_CV=0.1
DEFAULT_CV=0.3
rearrange="bystim"
model_structure = extractStructure(model_structure)
basal_activity = extractBasalActivity(basal_activity)
vpert = c(model_structure$names, paste0(model_structure$names, "i")) # Perturbations that can be simulated
data_file = extractMIDAS(data_filename)
data_values = data_file[,grepl("^DV.", colnames(data_file)),drop=FALSE]
colnames(data_values) = gsub("^[A-Z]{2}.", "", colnames(data_values))
not_included = setdiff(colnames(data_values), model_structure$names)
perturbations = data_file[,grepl("^TR.", colnames(data_file)),drop=FALSE]
if (ncol(perturbations) == 0) {
stop("Perturbation informations are required")
}
colnames(perturbations) = gsub("^[A-Z]{2}.", "", colnames(perturbations))
not_perturbable = setdiff(colnames(perturbations), vpert)
id_colums = grepl("^ID.type", colnames(data_file))
blanks = which(tolower(data_file[,id_colums]) %in% c("b","blank"))
controls = which(tolower(data_file[,id_colums]) %in% c("c","ctl","ctrl","control"))
if (length(controls) == 0) {
stop("Control experiments are required (indicated as 'control' in the column 'ID:type', see extractMIDAS)")
}
# Warn for the measured nodes that have not been found in the network, and don't use them
if (length(not_included) > 0) {
message(paste(not_included , "measurement is not in the network structure (could be a mispelling or a case error)\n"))
data_values = data_values[,-which(colnames(data_values) %in% not_included), drop=FALSE]
}
# Remove extra readouts that should not be used
for (ro in dont_read) {
if (ro %in% colnames(data_values)) {
message(paste(ro, "readout will not be used for the fit\n"))
data_values = data_values[,-which(colnames(data_values)==ro), drop=FALSE]
}
}
# Remove the perturbations that cannot be simulated to get a correct fit
for (erm in dont_perturb) {
if (!erm %in% vpert) {
message(paste0(erm, " is not a valid perturbation name for this dataset"))
}
}
dont_perturb = intersect(dont_perturb, vpert)
rm_rows = c()
if (length(not_perturbable) > 0 || length(dont_perturb) > 0) {
if (length(not_perturbable) > 0) {
message(paste(not_perturbable , "perturbation not compatible with the network structure, it will not be used\n" ))
}
if (length(dont_perturb) > 0) {
message(paste(dont_perturb, "perturbation will not be used for the fit\n"))
}
not_perturbable = c(not_perturbable, dont_perturb)
rm_rows = unique(unlist(lapply(not_perturbable, function(pp) { which(perturbations[,pp]==1) })))
perturbations = perturbations[,-which(colnames(perturbations) %in% not_perturbable), drop=F]
if (length(perturbations)==0){
stop("All perturbations have been removed can not continue modelling")
}
if (!any(perturbations[-rm_rows,]==1)){
stop("Remaining perturbations only occur in combination with removed perturbations, please reconsider perturbation scheme")
}
}
# Means of the blank fixation of the antibodies
if (length(blanks) == 0) {
blank_values = matrix( rep(0, ncol(data_values)), nrow=1, dimnames=list(NULL, colnames(data_values)) )
} else {
blank_values = colMeans(data_values[blanks,,drop=F], na.rm=T)
}
blank_values[is.nan(blank_values)|is.na(blank_values)] = 0 # For perturbations without blank values
# Means of basal activity of antibodies
unstim_values = colMeans(data_values[controls,,drop=F], na.rm=T)
if (any(is.nan(unstim_values)|is.na(unstim_values))) {
stop("Unstimulated data are required to simulate the network")
}
# Calculate statistics for variation data
if (length(c(rm_rows,blanks))>0){
mean_stat = aggregate(data_values[-c(rm_rows,blanks),,drop=FALSE], by=perturbations[-c(rm_rows,blanks),,drop=FALSE], mean, na.rm=T)[,-(1:ncol(perturbations)),drop=FALSE]
sd_stat = aggregate(data_values[-c(rm_rows,blanks),,drop=FALSE], by=perturbations[-c(rm_rows,blanks),,drop=FALSE], sd, na.rm=T)[,-(1:ncol(perturbations)),drop=FALSE]
} else {
mean_stat = aggregate(data_values, by=perturbations, mean, na.rm=TRUE)[,-(1:ncol(perturbations)),drop=FALSE]
sd_stat = aggregate(data_values, by=perturbations, sd, na.rm=TRUE)[,-(1:ncol(perturbations)),drop=FALSE]
}
# Delete the perturbations that cannot be used, blank and controls from the dataset
rm_rows = c(rm_rows, controls, blanks)
data_values = data_values[-rm_rows,,drop=F]
perturbations = perturbations[-rm_rows,,drop=F]
# Compute the mean and standard deviation of the data
mean_values = aggregate(data_values, by=perturbations, mean, na.rm=T)[,-(1:ncol(perturbations)),drop=F]
blank_values = matrix( rep(blank_values, each=nrow(mean_values)), nrow=nrow(mean_values), dimnames=list(NULL, colnames(data_values)) )
unstim_values = matrix(rep(unstim_values, each=nrow(mean_values)), nrow=nrow(mean_values))
colnames(unstim_values) <- colnames(mean_values)
if (verbose > 7) {
message("Data used:")
message(mean_values)
} else if (verbose > 5) {
message("Data used:")
message(head(mean_values))
}
# Error model
if (any(var_filename != "")) {
# We use the CV file if there is one
# The format and the order of the conditions are assumed to be the same as the data file
message(paste0("Using var file ", var_filename))
variation_file = extractMIDAS(var_filename)
# Check that the number of samples is the same for the measurements and the variation and that the names in the measurements file and in the variation file match
if (nrow(variation_file) != nrow(data_file)) {
stop("Different number of experiments for the variation and the measurement files")
}
notInVar = setdiff(colnames(data_file),colnames(variation_file))
if (length(notInVar)>0){
stop(paste0("Names of the variation and measurement files do not match","\n",
"Columns ",paste0(notInVar,collapse=" "),
" from data file are not found in var file!"))
}
# Reorder and filter variation columns to columns present in data file
variation_file=variation_file[,colnames(data_file)]
# Check whether the order and type of the perturbations is preserved
if (!all(data_file[,grepl("^TR.", colnames(data_file))]==variation_file[,grepl("^TR.", colnames(variation_file))])){
stop("Order or type of experiments in the variation file is different from the measurement file, please adapt them to be the same!")
}
# Gather the cv values corresponding to the experimental design
pre_cv = variation_file[, grepl("^DV", colnames(variation_file))]
colnames(pre_cv) = gsub("^[A-Z]{2}.", "", colnames(pre_cv))
cv_values = pre_cv[,colnames(pre_cv)%in%colnames(mean_values)]
cv_values = cv_values[-rm_rows,,drop=FALSE]
cv_values = aggregate(cv_values, by=perturbations, mean, na.rm=T)[,-(1:ncol(perturbations))]
} else {
# remove measurements not different from blank
mean_stat[mean_stat <= 2 * blank_values] = NA
median_cv = apply(sd_stat / mean_stat, 2, median, na.rm=T)
cv_values = matrix(rep(median_cv,each=nrow(mean_values)),nrow=nrow(mean_values))
}
colnames(cv_values)=colnames(mean_values)
cv_values[is.nan(as.matrix(cv_values)) | is.na(cv_values)] = DEFAULT_CV
cv_values[cv_values < MIN_CV] = MIN_CV
error = blank_values + cv_values * mean_values
error[error<1] = 1 # The error cannot be 0 as it is used for the fit. If we get 0 (which means blank=0 and stim_data=0), we set it to 1 (which mean the score will simply be (fit-data)^2 for those measurements). We also ensure that is is not too small (which would lead to a disproportionate fit attempt
# Extract experimental design
perturbations = aggregate(perturbations, by=perturbations, max, na.rm=T)[,-(1:ncol(perturbations)),drop=F]
names = colnames(perturbations)
stim_names = names[grepl("[^i]$", names)]
stim_nodes = as.character( stim_names[match(model_structure$names, stim_names, nomatch = 0)] )
names = gsub("i$", "", names[grepl("i$", names)])
inhib_nodes = as.character( names[match(model_structure$names, names, nomatch = 0 )] )
no_stim=F
no_inh=F
if (length(stim_nodes)>0){
stimuli = as.matrix(perturbations[,stim_nodes,drop=F])
} else{
stimuli = perturbations[,0]
no_stim=T
}
if (length(inhib_nodes)>0){
inhibitor = as.matrix(perturbations[,paste(inhib_nodes, "i", sep=""),drop=F])
}else if (no_stim){
stop("Neither a valid stimulation nor inhibition was given, at least one type is needed!")
}else{
inhibitor = perturbations[,0]
no_inh=T
}
measured_nodes = colnames(mean_values)
measured_nodes = measured_nodes[measured_nodes %in% model_structure$names] # Preserve the order in the file, allowing to specify the order of the readouts in the input
if (rearrange %in% c("bystim", "byinhib")) {
# Arrange data according to experimental design
stim_motifs = aggregate(stimuli,by=as.data.frame(stimuli),max,na.rm=T)[,-(1:ncol(stimuli)),drop=F] # sorts automatically
inh_motifs = aggregate(inhibitor,by=as.data.frame(inhibitor),max,na.rm=T)[,-(1:ncol(inhibitor)),drop=F] # sorts automatically
error_sort = error[0, measured_nodes,drop=F]
stim_data_sort = mean_values[0, measured_nodes,drop=F]
cv_sort = cv_values[0,measured_nodes,drop=F]
stim_sort = if (no_stim) {as.matrix(stimuli)} else{stimuli[0, ,drop=F]}
inh_sort = if (no_inh) {as.matrix(inhibitor)} else{inhibitor[0, ,drop=F]}
if (rearrange == "byinhib") { # Invert variables
tmp = stim_sort
stim_sort = inh_sort
inh_sort = tmp
tmp = no_stim
no_stim = no_inh
no_inh = tmp
tmp = stim_motifs
stim_motifs = inh_motifs
inh_motifs = tmp
tmp = stimuli
stimuli = inhibitor
inhibitor = tmp
}
if (!no_stim){
for (ii in 1:nrow(stim_motifs)){
stim_pos = apply(stimuli==matrix(rep(stim_motifs[ii,], each=nrow(stimuli)), nrow=nrow(stimuli)), 1, all)
if (!no_inh){
for (jj in 1:nrow(inh_motifs)){
inh_pos = apply(inhibitor==matrix(rep(inh_motifs[jj,], each=nrow(inhibitor)), nrow=nrow(inhibitor)), 1, all)
if (any(stim_pos & inh_pos)){
error_sort = rbind(error_sort, error[stim_pos & inh_pos, measured_nodes])
stim_data_sort = rbind(stim_data_sort, mean_values[stim_pos & inh_pos, measured_nodes])
cv_sort = rbind(cv_sort, cv_values[stim_pos & inh_pos, measured_nodes])
stim_sort = rbind(stim_sort, stimuli[stim_pos & inh_pos, ])
inh_sort = rbind(inh_sort, inhibitor[stim_pos & inh_pos, ])
}
}
}else if (any(stim_pos)){
error_sort = rbind(error_sort, error[stim_pos, measured_nodes])
stim_data_sort = rbind(stim_data_sort, mean_values[stim_pos, measured_nodes])
cv_sort = rbind(cv_sort, cv_values[stim_pos, measured_nodes])
stim_sort = rbind(stim_sort, stimuli[stim_pos, ])
}
}
}else{
for (jj in 1:nrow(inh_motifs)){
inh_pos = apply(inhibitor==matrix(rep(inh_motifs[jj,], each=nrow(inhibitor)), nrow=nrow(inhibitor)), 1, all)
if (any(inh_pos)){
error_sort = rbind(error_sort, error[inh_pos, measured_nodes])
stim_data_sort = rbind(stim_data_sort, mean_values[inh_pos, measured_nodes])
cv_sort = rbind(cv_sort, cv_values[inh_pos, measured_nodes])
inh_sort = rbind(inh_sort, inhibitor[inh_pos, ])
}
}
}
if (rearrange == "byinhib") { # Re-invert the variables that are used later
tmp = stim_sort
stim_sort = inh_sort
inh_sort = tmp
}
} else {
if (!rearrange %in% c("n", "no", "")) {
warning(paste0("Unknown option '", rearrange, "' for the arrangement of the perturbations, interpreted as 'no'"))
}
stim_sort = as.matrix(stimuli)
inh_sort = as.matrix(inhibitor)
stim_data_sort = mean_values[,measured_nodes, drop=FALSE]
cv_sort = cv_values[,measured_nodes, drop=FALSE]
error_sort = error[,measured_nodes, drop=FALSE]
}
if (verbose > 3) {
message("Stimulated nodes")
message(stim_sort)
message("Inhibited nodes")
message(inh_sort)
}
expdes=getExperimentalDesign(model_structure, stim_nodes, inhib_nodes, measured_nodes, stim_sort, inh_sort, basal_activity)
data=new(STASNet:::Data)
data$set_unstim_data ( unstim_values[, measured_nodes, drop=FALSE] )
data$set_scale( blank_values[, measured_nodes, drop=FALSE] )
data$set_stim_data( as.matrix(stim_data_sort[, measured_nodes, drop=FALSE]) )
stim_data_sort
measured_nodes
stim_motifs = aggregate(stimuli,by=as.data.frame(stimuli),max,na.rm=T)[,-(1:ncol(stimuli)),drop=F] # sorts automatically
inh_motifs = aggregate(inhibitor,by=as.data.frame(inhibitor),max,na.rm=T)[,-(1:ncol(inhibitor)),drop=F] # sorts automatically
error_sort = error[0, measured_nodes,drop=F]
stim_data_sort = mean_values[0, measured_nodes,drop=F]
stim_data_sort
mean_values
cv_sort = cv_values[0,measured_nodes,drop=F]
stim_sort = if (no_stim) {as.matrix(stimuli)} else{stimuli[0, ,drop=F]}
inh_sort = if (no_inh) {as.matrix(inhibitor)} else{inhibitor[0, ,drop=F]}
if (rearrange == "byinhib") { # Invert variables
tmp = stim_sort
stim_sort = inh_sort
inh_sort = tmp
tmp = no_stim
no_stim = no_inh
no_inh = tmp
tmp = stim_motifs
stim_motifs = inh_motifs
inh_motifs = tmp
tmp = stimuli
stimuli = inhibitor
inhibitor = tmp
}
rearrange
(!no_stim)
stim_motifs
ii=1
stim_pos = apply(stimuli==matrix(rep(stim_motifs[ii,], each=nrow(stimuli)), nrow=nrow(stimuli)), 1, all)
stim_pos
(!no_inh)
jj=1
nrow(inh_motifs)
inh_pos = apply(inhibitor==matrix(rep(inh_motifs[jj,], each=nrow(inhibitor)), nrow=nrow(inhibitor)), 1, all)
inh_pos
stim_pos & inh_pos
error
error_sort
error_sort = rbind(error_sort, error[stim_pos & inh_pos, measured_nodes])
error_sort
error_sort = error[0, measured_nodes,drop=F]
error_sort
rbind(error_sort, as.matrix(error[stim_pos & inh_pos, measured_nodes]))
?rbind
error
rbind(error_sort, error[stim_pos & inh_pos, measured_nodes,drop=F])
if (rearrange %in% c("bystim", "byinhib")) {
# Arrange data according to experimental design
stim_motifs = aggregate(stimuli,by=as.data.frame(stimuli),max,na.rm=T)[,-(1:ncol(stimuli)),drop=F] # sorts automatically
inh_motifs = aggregate(inhibitor,by=as.data.frame(inhibitor),max,na.rm=T)[,-(1:ncol(inhibitor)),drop=F] # sorts automatically
error_sort = error[0, measured_nodes,drop=F]
stim_data_sort = mean_values[0, measured_nodes,drop=F]
cv_sort = cv_values[0,measured_nodes,drop=F]
stim_sort = if (no_stim) {as.matrix(stimuli)} else{stimuli[0, ,drop=F]}
inh_sort = if (no_inh) {as.matrix(inhibitor)} else{inhibitor[0, ,drop=F]}
if (rearrange == "byinhib") { # Invert variables
tmp = stim_sort
stim_sort = inh_sort
inh_sort = tmp
tmp = no_stim
no_stim = no_inh
no_inh = tmp
tmp = stim_motifs
stim_motifs = inh_motifs
inh_motifs = tmp
tmp = stimuli
stimuli = inhibitor
inhibitor = tmp
}
if (!no_stim){
for (ii in 1:nrow(stim_motifs)){
stim_pos = apply(stimuli==matrix(rep(stim_motifs[ii,], each=nrow(stimuli)), nrow=nrow(stimuli)), 1, all)
if (!no_inh){
for (jj in 1:nrow(inh_motifs)){
inh_pos = apply(inhibitor==matrix(rep(inh_motifs[jj,], each=nrow(inhibitor)), nrow=nrow(inhibitor)), 1, all)
if (any(stim_pos & inh_pos)){
error_sort = rbind(error_sort, error[stim_pos & inh_pos, measured_nodes,drop=F])
stim_data_sort = rbind(stim_data_sort, mean_values[stim_pos & inh_pos, measured_nodes, drop=F])
cv_sort = rbind(cv_sort, cv_values[stim_pos & inh_pos, measured_nodes, drop=F])
stim_sort = rbind(stim_sort, stimuli[stim_pos & inh_pos, ,drop=F])
inh_sort = rbind(inh_sort, inhibitor[stim_pos & inh_pos, ,drop=F])
}
}
}else if (any(stim_pos)){
error_sort = rbind(error_sort, error[stim_pos, measured_nodes,drop=F])
stim_data_sort = rbind(stim_data_sort, mean_values[stim_pos, measured_nodes,drop=F])
cv_sort = rbind(cv_sort, cv_values[stim_pos, measured_nodes,drop=F])
stim_sort = rbind(stim_sort, stimuli[stim_pos, ,drop=F])
}
}
}else{
for (jj in 1:nrow(inh_motifs)){
inh_pos = apply(inhibitor==matrix(rep(inh_motifs[jj,], each=nrow(inhibitor)), nrow=nrow(inhibitor)), 1, all)
if (any(inh_pos)){
error_sort = rbind(error_sort, error[inh_pos, measured_nodes,drop=F])
stim_data_sort = rbind(stim_data_sort, mean_values[inh_pos, measured_nodes,drop=F])
cv_sort = rbind(cv_sort, cv_values[inh_pos, measured_nodes,drop=F])
inh_sort = rbind(inh_sort, inhibitor[inh_pos, ,drop=F])
}
}
}
if (rearrange == "byinhib") { # Re-invert the variables that are used later
tmp = stim_sort
stim_sort = inh_sort
inh_sort = tmp
}
} else {
if (!rearrange %in% c("n", "no", "")) {
warning(paste0("Unknown option '", rearrange, "' for the arrangement of the perturbations, interpreted as 'no'"))
}
stim_sort = as.matrix(stimuli)
inh_sort = as.matrix(inhibitor)
stim_data_sort = mean_values[,measured_nodes, drop=FALSE]
cv_sort = cv_values[,measured_nodes, drop=FALSE]
err
measured_nodes = colnames(mean_values)
measured_nodes = measured_nodes[measured_nodes %in% model_structure$names] # Preserve the order in the file, allowing to specify the order of the readouts in the input
if (rearrange %in% c("bystim", "byinhib")) {
# Arrange data according to experimental design
stim_motifs = aggregate(stimuli,by=as.data.frame(stimuli),max,na.rm=T)[,-(1:ncol(stimuli)),drop=F] # sorts automatically
inh_motifs = aggregate(inhibitor,by=as.data.frame(inhibitor),max,na.rm=T)[,-(1:ncol(inhibitor)),drop=F] # sorts automatically
error_sort = error[0, measured_nodes,drop=F]
stim_data_sort = mean_values[0, measured_nodes,drop=F]
cv_sort = cv_values[0,measured_nodes,drop=F]
stim_sort = if (no_stim) {as.matrix(stimuli)} else{stimuli[0, ,drop=F]}
inh_sort = if (no_inh) {as.matrix(inhibitor)} else{inhibitor[0, ,drop=F]}
if (rearrange == "byinhib") { # Invert variables
tmp = stim_sort
stim_sort = inh_sort
inh_sort = tmp
tmp = no_stim
no_stim = no_inh
no_inh = tmp
tmp = stim_motifs
stim_motifs = inh_motifs
inh_motifs = tmp
tmp = stimuli
stimuli = inhibitor
inhibitor = tmp
}
if (!no_stim){
for (ii in 1:nrow(stim_motifs)){
stim_pos = apply(stimuli==matrix(rep(stim_motifs[ii,], each=nrow(stimuli)), nrow=nrow(stimuli)), 1, all)
if (!no_inh){
for (jj in 1:nrow(inh_motifs)){
inh_pos = apply(inhibitor==matrix(rep(inh_motifs[jj,], each=nrow(inhibitor)), nrow=nrow(inhibitor)), 1, all)
if (any(stim_pos & inh_pos)){
error_sort = rbind(error_sort, error[stim_pos & inh_pos, measured_nodes,drop=F])
stim_data_sort = rbind(stim_data_sort, mean_values[stim_pos & inh_pos, measured_nodes, drop=F])
cv_sort = rbind(cv_sort, cv_values[stim_pos & inh_pos, measured_nodes, drop=F])
stim_sort = rbind(stim_sort, stimuli[stim_pos & inh_pos, ,drop=F])
inh_sort = rbind(inh_sort, inhibitor[stim_pos & inh_pos, ,drop=F])
}
}
}else if (any(stim_pos)){
error_sort = rbind(error_sort, error[stim_pos, measured_nodes,drop=F])
stim_data_sort = rbind(stim_data_sort, mean_values[stim_pos, measured_nodes,drop=F])
cv_sort = rbind(cv_sort, cv_values[stim_pos, measured_nodes,drop=F])
stim_sort = rbind(stim_sort, stimuli[stim_pos, ,drop=F])
}
}
}else{
for (jj in 1:nrow(inh_motifs)){
inh_pos = apply(inhibitor==matrix(rep(inh_motifs[jj,], each=nrow(inhibitor)), nrow=nrow(inhibitor)), 1, all)
if (any(inh_pos)){
error_sort = rbind(error_sort, error[inh_pos, measured_nodes,drop=F])
stim_data_sort = rbind(stim_data_sort, mean_values[inh_pos, measured_nodes,drop=F])
cv_sort = rbind(cv_sort, cv_values[inh_pos, measured_nodes,drop=F])
inh_sort = rbind(inh_sort, inhibitor[inh_pos, ,drop=F])
}
}
}
if (rearrange == "byinhib") { # Re-invert the variables that are used later
tmp = stim_sort
stim_sort = inh_sort
inh_sort = tmp
}
} else {
if (!rearrange %in% c("n", "no", "")) {
warning(paste0("Unknown option '", rearrange, "' for the arrangement of the perturbations, interpreted as 'no'"))
}
stim_sort = as.matrix(stimuli)
inh_sort = as.matrix(inhibitor)
stim_data_sort = mean_values[,measured_nodes, drop=FALSE]
cv_sort = cv_values[,measured_nodes, drop=FALSE]
error_sort = error[,measured_nodes, drop=FALSE]
}
expdes=STASNet:::getExperimentalDesign(model_structure, stim_nodes, inhib_nodes, measured_nodes, stim_sort, inh_sort, basal_activity)
data=new(STASNet:::Data)
data$set_unstim_data ( unstim_values[, measured_nodes, drop=FALSE] )
data$set_scale( blank_values[, measured_nodes, drop=FALSE] )
data$set_stim_data( as.matrix(stim_data_sort[, measured_nodes, drop=FALSE]) )
data$set_error( as.matrix( error_sort[, measured_nodes, drop=FALSE] ))
stim_data_sort
measured_nodes
error_sort
